{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RxDogTag RxDogTag is a utility to tag originating subscribe points in RxJava 2 observers, with the goal of surfacing their subscribe locations for error reporting/investigation later in the event of an unhandled error. This is only for RxJava observers that do not implement onError() . Download implementation( com.uber.rxdogtag:rxdogtag:x.y.z ) Setup Install early in your application lifecycle via RxDogTag.install() . This will install the necessary hooks in RxJavaPlugins . Note that these will replace any existing plugins at the hooks it uses. See the JavaDoc for full details of which plugins it uses. Example Consider the following classic RxJava error: Observable . range ( 0 , 10 ) . subscribeOn ( Schedulers . io ()) . map ( i - null ) . subscribe (); This is a fairly common case in RxJava concurrency. Without tagging, this yields the following trace: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | The mapper function returned a null value. at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.BasicFuseableObserver.onError(BasicFuseableObserver.java:100) at io.reactivex.internal.observers.BasicFuseableObserver.fail(BasicFuseableObserver.java:110) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:59) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NullPointerException: The mapper function returned a null value. at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) ... 14 more This is basically impossible to investigate if you re looking at a crash report from the wild. Now the same error with RxDogTag enabled: io.reactivex.exceptions.OnErrorNotImplementedException: The mapper function returned a null value. Caused by: java.lang.NullPointerException: The mapper function returned a null value. at com.uber.anotherpackage.ReadMeExample.complex(ReadMeExample.java:55) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Now we have the example subscribe line at ReadMeExample.java:55 . It may not be a silver bullet to root-causing why the exception occurred, but at least you know where it s emanating from. The subscribe line reported should also retrace and group well for crash reporting. As we use our own in-house reporter though, we re very open to feedback on how this can be improved for other solutions. More examples and details can be found in the wiki Configuration RxDogTag has an alternative RxDogTag.builder() API to facilitate added configuration, such as annotation control, stacktrace element location, and more. Custom handlers In the event of custom observers that possibly decorate other observer types, this information can be passed to RxDogTag via the ObserverHandler interface. This interface can be used to unwrap these custom observers to reveal their delegates and their potential behavior. Install these via the RxDogTag.Builder#addObserverHandlers(...) overloads that accept handlers. Ignored packages RxDogTag needs to ignore certain packages (such as its own or RxJava s) when inspecting stack traces to deduce the subscribe point. You can add other custom ones via RxDogTag.Builder#addIgnoredPackages(...) . AutoDispose support AutoDispose is a library for automatically disposing streams, and works via its own decorating observers under the hood. AutoDispose can work with RxDogTag via its delegateObserver() APIs on the AutoDisposingObserver interfaces. Support for this is available via separate rxdogtag-autodispose artifact and its AutoDisposeObserverHandler singleton instance. RxDogTag . builder () . configureWith ( AutoDisposeConfigurer :: configure ) . install (); implementation( com.uber.rxdogtag:rxdogtag-autodispose:x.y.z ) Development Javadocs for the most recent release can be found here: https://uber.github.io/RxDogTag/0.x/rxdogtag/com.uber.rxdogtag/ Snapshots of the development version are available in Sonatype s snapshots repository . License Copyright (C) 2019 Uber Technologies Licensed under the Apache License, Version 2.0 (the License ); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#rxdogtag","text":"RxDogTag is a utility to tag originating subscribe points in RxJava 2 observers, with the goal of surfacing their subscribe locations for error reporting/investigation later in the event of an unhandled error. This is only for RxJava observers that do not implement onError() .","title":"RxDogTag"},{"location":"#download","text":"implementation( com.uber.rxdogtag:rxdogtag:x.y.z )","title":"Download"},{"location":"#setup","text":"Install early in your application lifecycle via RxDogTag.install() . This will install the necessary hooks in RxJavaPlugins . Note that these will replace any existing plugins at the hooks it uses. See the JavaDoc for full details of which plugins it uses.","title":"Setup"},{"location":"#example","text":"Consider the following classic RxJava error: Observable . range ( 0 , 10 ) . subscribeOn ( Schedulers . io ()) . map ( i - null ) . subscribe (); This is a fairly common case in RxJava concurrency. Without tagging, this yields the following trace: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | The mapper function returned a null value. at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.BasicFuseableObserver.onError(BasicFuseableObserver.java:100) at io.reactivex.internal.observers.BasicFuseableObserver.fail(BasicFuseableObserver.java:110) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:59) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NullPointerException: The mapper function returned a null value. at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) ... 14 more This is basically impossible to investigate if you re looking at a crash report from the wild. Now the same error with RxDogTag enabled: io.reactivex.exceptions.OnErrorNotImplementedException: The mapper function returned a null value. Caused by: java.lang.NullPointerException: The mapper function returned a null value. at com.uber.anotherpackage.ReadMeExample.complex(ReadMeExample.java:55) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Now we have the example subscribe line at ReadMeExample.java:55 . It may not be a silver bullet to root-causing why the exception occurred, but at least you know where it s emanating from. The subscribe line reported should also retrace and group well for crash reporting. As we use our own in-house reporter though, we re very open to feedback on how this can be improved for other solutions. More examples and details can be found in the wiki","title":"Example"},{"location":"#configuration","text":"RxDogTag has an alternative RxDogTag.builder() API to facilitate added configuration, such as annotation control, stacktrace element location, and more.","title":"Configuration"},{"location":"#custom-handlers","text":"In the event of custom observers that possibly decorate other observer types, this information can be passed to RxDogTag via the ObserverHandler interface. This interface can be used to unwrap these custom observers to reveal their delegates and their potential behavior. Install these via the RxDogTag.Builder#addObserverHandlers(...) overloads that accept handlers.","title":"Custom handlers"},{"location":"#ignored-packages","text":"RxDogTag needs to ignore certain packages (such as its own or RxJava s) when inspecting stack traces to deduce the subscribe point. You can add other custom ones via RxDogTag.Builder#addIgnoredPackages(...) .","title":"Ignored packages"},{"location":"#autodispose-support","text":"AutoDispose is a library for automatically disposing streams, and works via its own decorating observers under the hood. AutoDispose can work with RxDogTag via its delegateObserver() APIs on the AutoDisposingObserver interfaces. Support for this is available via separate rxdogtag-autodispose artifact and its AutoDisposeObserverHandler singleton instance. RxDogTag . builder () . configureWith ( AutoDisposeConfigurer :: configure ) . install (); implementation( com.uber.rxdogtag:rxdogtag-autodispose:x.y.z )","title":"AutoDispose support"},{"location":"#development","text":"Javadocs for the most recent release can be found here: https://uber.github.io/RxDogTag/0.x/rxdogtag/com.uber.rxdogtag/ Snapshots of the development version are available in Sonatype s snapshots repository .","title":"Development"},{"location":"#license","text":"Copyright (C) 2019 Uber Technologies Licensed under the Apache License, Version 2.0 (the License ); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"benchmark/","text":"Benchmarks Running the benchmark You can run the benchmark by executing ./gradlew :android-benchmark:benchmark:connectedCheck . Note that the benchmark should be run on an actual device You can then take the output from the benchmark and run it through DataParser.kt to get a structured breakdown as seen below. It s important to look at the units. In general, RxDogTag does add some overhead to your RxJava subscriptions but that overhead is irrelevant in the larger execution context of the code around it (less than a millisecond in most cases). Running the benchmark on a Pixel 3 yields the below results. Event throughput: grouped by number of events Measures the amount of time it takes for given number of elements to pass through the stream. Simple: 1 item (Observable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.001ms 532ns true false 0.007ms 7,060ns true true 0.007ms 7,378ns Complex: 1 item (Observable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) true false 0.049ms 49,195ns true true 0.050ms 50,492ns false false 0.054ms 53,672ns Simple: 1_000 items (Observable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.024ms 23,968ns true false 0.041ms 40,743ns true true 0.153ms 152,943ns Complex: 1_000 items (Observable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.291ms 291,301ns true false 0.313ms 312,864ns true true 0.313ms 313,334ns Simple: 1_000_000 items (Observable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 23.994ms 23,993,700ns true false 27.305ms 27,304,847ns true true 166.887ms 166,887,047ns Complex: 1_000_000 items (Observable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) true false 249.740ms 249,739,764ns false false 252.728ms 252,727,577ns true true 257.554ms 257,553,671ns Simple: 1 item (Flowable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.001ms 519ns true false 0.007ms 7,234ns true true 0.008ms 7,581ns Complex: 1 item (Flowable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) true false 0.050ms 50,081ns true true 0.051ms 50,787ns false false 0.056ms 56,004ns Simple: 1_000 items (Flowable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.025ms 24,920ns true false 0.041ms 40,568ns true true 0.153ms 153,124ns Complex: 1_000 items (Flowable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.273ms 273,178ns true true 0.343ms 342,812ns true false 0.375ms 375,208ns Simple: 1_000_000 items (Flowable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 23.953ms 23,952,919ns true false 26.792ms 26,791,825ns true true 162.547ms 162,547,359ns Complex: 1_000_000 items (Flowable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) true true 300.186ms 300,186,228ns true false 302.881ms 302,880,498ns false false 304.952ms 304,952,062ns Subscribe cost: grouped by complexity Measures the cost to subscription incurred by RxDogTag. Subscription means no emissions, subscription only. Simple (Observable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.000ms 331ns true false 0.007ms 7,275ns Simple (Flowable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.000ms 365ns true false 0.008ms 7,506ns Complex (Observable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.002ms 1,673ns true false 0.010ms 9,770ns Complex (Flowable) RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.006ms 5,741ns true false 0.021ms 20,783ns","title":"Benchmark"},{"location":"benchmark/#benchmarks","text":"","title":"Benchmarks"},{"location":"benchmark/#running-the-benchmark","text":"You can run the benchmark by executing ./gradlew :android-benchmark:benchmark:connectedCheck . Note that the benchmark should be run on an actual device You can then take the output from the benchmark and run it through DataParser.kt to get a structured breakdown as seen below. It s important to look at the units. In general, RxDogTag does add some overhead to your RxJava subscriptions but that overhead is irrelevant in the larger execution context of the code around it (less than a millisecond in most cases). Running the benchmark on a Pixel 3 yields the below results.","title":"Running the benchmark"},{"location":"benchmark/#event-throughput-grouped-by-number-of-events","text":"Measures the amount of time it takes for given number of elements to pass through the stream.","title":"Event throughput: grouped by number of events"},{"location":"benchmark/#simple-1-item-observable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.001ms 532ns true false 0.007ms 7,060ns true true 0.007ms 7,378ns","title":"Simple: 1 item (Observable)"},{"location":"benchmark/#complex-1-item-observable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) true false 0.049ms 49,195ns true true 0.050ms 50,492ns false false 0.054ms 53,672ns","title":"Complex: 1 item (Observable)"},{"location":"benchmark/#simple-1_000-items-observable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.024ms 23,968ns true false 0.041ms 40,743ns true true 0.153ms 152,943ns","title":"Simple: 1_000 items (Observable)"},{"location":"benchmark/#complex-1_000-items-observable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.291ms 291,301ns true false 0.313ms 312,864ns true true 0.313ms 313,334ns","title":"Complex: 1_000 items (Observable)"},{"location":"benchmark/#simple-1_000_000-items-observable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 23.994ms 23,993,700ns true false 27.305ms 27,304,847ns true true 166.887ms 166,887,047ns","title":"Simple: 1_000_000 items (Observable)"},{"location":"benchmark/#complex-1_000_000-items-observable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) true false 249.740ms 249,739,764ns false false 252.728ms 252,727,577ns true true 257.554ms 257,553,671ns","title":"Complex: 1_000_000 items (Observable)"},{"location":"benchmark/#simple-1-item-flowable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.001ms 519ns true false 0.007ms 7,234ns true true 0.008ms 7,581ns","title":"Simple: 1 item (Flowable)"},{"location":"benchmark/#complex-1-item-flowable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) true false 0.050ms 50,081ns true true 0.051ms 50,787ns false false 0.056ms 56,004ns","title":"Complex: 1 item (Flowable)"},{"location":"benchmark/#simple-1_000-items-flowable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.025ms 24,920ns true false 0.041ms 40,568ns true true 0.153ms 153,124ns","title":"Simple: 1_000 items (Flowable)"},{"location":"benchmark/#complex-1_000-items-flowable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.273ms 273,178ns true true 0.343ms 342,812ns true false 0.375ms 375,208ns","title":"Complex: 1_000 items (Flowable)"},{"location":"benchmark/#simple-1_000_000-items-flowable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 23.953ms 23,952,919ns true false 26.792ms 26,791,825ns true true 162.547ms 162,547,359ns","title":"Simple: 1_000_000 items (Flowable)"},{"location":"benchmark/#complex-1_000_000-items-flowable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) true true 300.186ms 300,186,228ns true false 302.881ms 302,880,498ns false false 304.952ms 304,952,062ns","title":"Complex: 1_000_000 items (Flowable)"},{"location":"benchmark/#subscribe-cost-grouped-by-complexity","text":"Measures the cost to subscription incurred by RxDogTag. Subscription means no emissions, subscription only.","title":"Subscribe cost: grouped by complexity"},{"location":"benchmark/#simple-observable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.000ms 331ns true false 0.007ms 7,275ns","title":"Simple (Observable)"},{"location":"benchmark/#simple-flowable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.000ms 365ns true false 0.008ms 7,506ns","title":"Simple (Flowable)"},{"location":"benchmark/#complex-observable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.002ms 1,673ns true false 0.010ms 9,770ns","title":"Complex (Observable)"},{"location":"benchmark/#complex-flowable","text":"RxDogTag Enabled Guarded Observer Callbacks Enabled Time (ms) Time (ns) false false 0.006ms 5,741ns true false 0.021ms 20,783ns","title":"Complex (Flowable)"},{"location":"changelog/","text":"Changelog Version 1.0.0 2020_03_07 Stable release! This release is identical in functionality to 0.3.0. Various dependency upgrades. ( #55 ) RxJava 2.2.18 AutoDispose 1.4.0 Android Benchmark 1.0.0 Version 0.3.0 2019-09-23 New: Builder option to disable guarded observer callbacks. #43 By default, RxDogTag will try/catch every onNext/onSuccess/onComplete calls in its observers to try to catch exceptions and modify the trace before they re handed to the (unhandled) onError. If you only want to handle upstream errors, you can disable this behavior in the builder now. This can be useful in hot paths where performance is more of a concern. RxDogTag . builder () . guardObserverCallbacks ( false ) . install (); New: ErrorReceivers API. #45 For users that have custom onError() implementations but want to supplement it with RxDogTag, there are two new APIs to help with this. RxDogTagErrorReceiver is a simple interface that your custom observer can implement to indicate that it wants its onError() method to be called with the aforementioned guarded observer callback. Note however that modified tagged exceptions in this case will be delivered to RxJavaPlugins.onError() . RxDogTagTaggedExceptionReceiver is an interface that your custom observer can implement to indicate that it wants its onError() called with the modified tagged exception. This is useful if you have custom onError() handling but want to use/report RxDogTag s tagged information for something custom. Misc - Proguard file has been tuned to use the more idiomatic -keeppackagenames . #29 - We have a website now! https://uber.github.io/RxDogTag - We ve been doing a lot of work to add thorough benchmarks for RxDogTag. A dedicated section can be found on the website at https://uber.github.io/RxDogTag/benchmark . Special thanks to @emartynov for contributing to this release! Version 0.2.0 2019-05-14 New: Builder-based API for configuration RxDogTag now uses a builder API for configuration. Currently this includes the existing ObserverHandler and package whitelisting, as well as a new configuration to optionally disable stacktrace annotations. RxDogTag . builder () . disableAnnotations () . addObserverHandlers (...) . addIgnoredPackages (...) . configureWith (...) // For other custom AutoDispose.Configurers . install (); Note: No-config RxDogTag.install() still exists, but is now just a proxy to RxDogTag.builder().install() Breaking changes: * ObserverHandler no longer handles package whitelisting, as this is now moved to the builder API. * The AutoDispose artifact now uses the builder API s configureWith support, and AutoDisposeObserverHandler is now just a package-private implementation detail. RxDogTag . builder () . configureWith ( AutoDisposeConfigurer :: configure ) . install (); New: Inferred subscribe point is now the first element in the stacktrace. After discussions with others in the community, the inferred subscribe point is now the first element in the stacktrace for better grouping with crash reporters (which may have otherwise accidentally grouped the stacktrace header annotations as the same crash). This plus some arrow characters means the stacktraces look like this: io.reactivex.exceptions.OnErrorNotImplementedException: The mapper function returned a null value. Caused by: java.lang.NullPointerException: The mapper function returned a null value. at com.uber.anotherpackage.ReadMeExample.complex(ReadMeExample.java:55) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) // ... and so on Version 0.1.0 2019-04-09 Initial release!","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#version-100","text":"2020_03_07 Stable release! This release is identical in functionality to 0.3.0. Various dependency upgrades. ( #55 ) RxJava 2.2.18 AutoDispose 1.4.0 Android Benchmark 1.0.0","title":"Version 1.0.0"},{"location":"changelog/#version-030","text":"2019-09-23 New: Builder option to disable guarded observer callbacks. #43 By default, RxDogTag will try/catch every onNext/onSuccess/onComplete calls in its observers to try to catch exceptions and modify the trace before they re handed to the (unhandled) onError. If you only want to handle upstream errors, you can disable this behavior in the builder now. This can be useful in hot paths where performance is more of a concern. RxDogTag . builder () . guardObserverCallbacks ( false ) . install (); New: ErrorReceivers API. #45 For users that have custom onError() implementations but want to supplement it with RxDogTag, there are two new APIs to help with this. RxDogTagErrorReceiver is a simple interface that your custom observer can implement to indicate that it wants its onError() method to be called with the aforementioned guarded observer callback. Note however that modified tagged exceptions in this case will be delivered to RxJavaPlugins.onError() . RxDogTagTaggedExceptionReceiver is an interface that your custom observer can implement to indicate that it wants its onError() called with the modified tagged exception. This is useful if you have custom onError() handling but want to use/report RxDogTag s tagged information for something custom. Misc - Proguard file has been tuned to use the more idiomatic -keeppackagenames . #29 - We have a website now! https://uber.github.io/RxDogTag - We ve been doing a lot of work to add thorough benchmarks for RxDogTag. A dedicated section can be found on the website at https://uber.github.io/RxDogTag/benchmark . Special thanks to @emartynov for contributing to this release!","title":"Version 0.3.0"},{"location":"changelog/#version-020","text":"2019-05-14 New: Builder-based API for configuration RxDogTag now uses a builder API for configuration. Currently this includes the existing ObserverHandler and package whitelisting, as well as a new configuration to optionally disable stacktrace annotations. RxDogTag . builder () . disableAnnotations () . addObserverHandlers (...) . addIgnoredPackages (...) . configureWith (...) // For other custom AutoDispose.Configurers . install (); Note: No-config RxDogTag.install() still exists, but is now just a proxy to RxDogTag.builder().install() Breaking changes: * ObserverHandler no longer handles package whitelisting, as this is now moved to the builder API. * The AutoDispose artifact now uses the builder API s configureWith support, and AutoDisposeObserverHandler is now just a package-private implementation detail. RxDogTag . builder () . configureWith ( AutoDisposeConfigurer :: configure ) . install (); New: Inferred subscribe point is now the first element in the stacktrace. After discussions with others in the community, the inferred subscribe point is now the first element in the stacktrace for better grouping with crash reporters (which may have otherwise accidentally grouped the stacktrace header annotations as the same crash). This plus some arrow characters means the stacktraces look like this: io.reactivex.exceptions.OnErrorNotImplementedException: The mapper function returned a null value. Caused by: java.lang.NullPointerException: The mapper function returned a null value. at com.uber.anotherpackage.ReadMeExample.complex(ReadMeExample.java:55) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) // ... and so on","title":"Version 0.2.0"},{"location":"changelog/#version-010","text":"2019-04-09 Initial release!","title":"Version 0.1.0"},{"location":"code-of-conduct/","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at . The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project s leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/","title":"Code of Conduct"},{"location":"code-of-conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at . The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project s leadership.","title":"Enforcement"},{"location":"code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/","title":"Attribution"},{"location":"contributing/","text":"Contributing to RxDogTag The Uber team welcomes contributions of all kinds, from simple bug reports through documentation, test cases, bugfixes, and features. Workflow We love GitHub issues! For small feature requests, an issue first proposing it for discussion or demo implementation in a PR suffice. For big features, please open an issue so that we can agree on the direction, and hopefully avoid investing a lot of time on a feature that might need reworking. Small pull requests for things like typos, bugfixes, etc are always welcome. Code style This project uses ktlint and GJF , provided via the spotless gradle plugin. If you find that one of your pull reviews does not pass the CI server check due to a code style conflict, you can easily fix it by running: ./gradlew spotlessApply. Generally speaking - we use vanilla ktlint + 2space indents, and vanilla GJF. You can integrate both of these in IntelliJ code style via either GJF s official plugin or applying code style from Jetbrains official style. No star imports please! DOs and DON Ts DO follow our coding style DO include tests when adding new features. When fixing bugs, start with adding a test that highlights how the current behavior is broken. DO keep the discussions focused. When a new or related topic comes up it s often better to create new issue than to side track the discussion. DO run all Gradle verification tasks ( ./gradlew check ) before submitting a pull request DON T submit PRs that alter licensing related files or headers. If you believe there s a problem with them, file an issue and we ll be happy to discuss it.","title":"Contributing"},{"location":"contributing/#contributing-to-rxdogtag","text":"The Uber team welcomes contributions of all kinds, from simple bug reports through documentation, test cases, bugfixes, and features.","title":"Contributing to RxDogTag"},{"location":"contributing/#workflow","text":"We love GitHub issues! For small feature requests, an issue first proposing it for discussion or demo implementation in a PR suffice. For big features, please open an issue so that we can agree on the direction, and hopefully avoid investing a lot of time on a feature that might need reworking. Small pull requests for things like typos, bugfixes, etc are always welcome.","title":"Workflow"},{"location":"contributing/#code-style","text":"This project uses ktlint and GJF , provided via the spotless gradle plugin. If you find that one of your pull reviews does not pass the CI server check due to a code style conflict, you can easily fix it by running: ./gradlew spotlessApply. Generally speaking - we use vanilla ktlint + 2space indents, and vanilla GJF. You can integrate both of these in IntelliJ code style via either GJF s official plugin or applying code style from Jetbrains official style. No star imports please!","title":"Code style"},{"location":"contributing/#dos-and-donts","text":"DO follow our coding style DO include tests when adding new features. When fixing bugs, start with adding a test that highlights how the current behavior is broken. DO keep the discussions focused. When a new or related topic comes up it s often better to create new issue than to side track the discussion. DO run all Gradle verification tasks ( ./gradlew check ) before submitting a pull request DON T submit PRs that alter licensing related files or headers. If you believe there s a problem with them, file an issue and we ll be happy to discuss it.","title":"DOs and DON'Ts"},{"location":"examples/","text":"Examples Simple Consider the following trivial case of emitting an error with no error handling. Observable . error ( new RuntimeException ( Unhandled error! )) . subscribe (); This results in a stacktrace like this: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | Unhandled error! at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63) at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:38) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.Observable.subscribe(Observable.java:12076) at io.reactivex.Observable.subscribe(Observable.java:11954) at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:26) collapsed internal calls Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:25) ... 25 more Now let s look at the same example with tagging enabled: io.reactivex.exceptions.OnErrorNotImplementedException: Unhandled error! Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:26) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:25) ... 25 more In the simple case, there s not much added benefit since the execution was synchronous and single threaded, but you can see original trace has now been updated to indicate the exact line that subscribe() was called. In this case: ReadMeExample.java:26 . To reduce noise - RxDogTag will wrap the original cause in a synthetic OnErrorNotImplementedException . This uses the original cause s message and doesn t fill in the stacktrace as it s irrelevant to the trace. Threading Consider a more complex example with threading: Observable . just ( 1 ) . subscribeOn ( Schedulers . io ()) . map ( i - null ) . subscribe (); This is a fairly common case in RxJava concurrency. Without tagging, this yields the following trace: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | The mapper function returned a null value. at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.BasicFuseableObserver.onError(BasicFuseableObserver.java:100) at io.reactivex.internal.observers.BasicFuseableObserver.fail(BasicFuseableObserver.java:110) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:59) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NullPointerException: The mapper function returned a null value. at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) ... 14 more Yikes! This is basically impossible to investigate if you re looking at a crash report from the wild. Now the same trace with tagging enabled: io.reactivex.exceptions.OnErrorNotImplementedException: The mapper function returned a null value. Caused by: java.lang.NullPointerException: The mapper function returned a null value. at com.uber.anotherpackage.ReadMeExample.complex(ReadMeExample.java:55) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Now we have the example subscribe line at ReadMeExample.java:55 . It may not be a silver bullet to root-causing why the exception occurred, but at least you know where it s emanating from. Delegate callbacks Let s look at one more example. This is similar to the previous, but instead of the exception occurring upstream in the chain, the exception occurs in one of the observer callbacks; in this case - onNext . Observable . just ( 1 ) . subscribeOn ( Schedulers . io ()) . subscribe ( i - throwSomething ()); private void throwSomething () { throw new RuntimeException ( Unhandled error! ); } Without tagging, this yields the following trace: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | Unhandled error! at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:67) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.throwSomething(ReadMeExample.java:68) at com.uber.anotherpackage.ReadMeExample.lambda$complexDelegate$1(ReadMeExample.java:63) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:63) ... 14 more Similar to the first example, this isn t terrible to root-cause. onNext is throwing a traceable exception in this trivial case. With tagging enabled: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | Unhandled error! at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:67) at com.uber.rxdogtag.DogTagObserver.lambda$onNext$3(DogTagObserver.java:53) at com.uber.rxdogtag.RxDogTag.guardedDelegateCall(RxDogTag.java:262) at com.uber.rxdogtag.DogTagObserver.onNext(DogTagObserver.java:53) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.complexDelegate(ReadMeExample.java:63) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ Originating callback: onNext ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at com.uber.anotherpackage.ReadMeExample.throwSomething(ReadMeExample.java:68) at com.uber.anotherpackage.ReadMeExample.lambda$complexDelegate$1(ReadMeExample.java:63) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:63) ... 17 more Now we re given added context that this occurred in the onNext callback according to [[ Originating callback: onNext ]] at the subscribe() call at ReadMeExample.java:63 . This callback handling is supported for all the standard callbacks and will report the correct name for each ( onSuccess , onComplete , etc).","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#simple","text":"Consider the following trivial case of emitting an error with no error handling. Observable . error ( new RuntimeException ( Unhandled error! )) . subscribe (); This results in a stacktrace like this: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | Unhandled error! at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63) at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:38) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.Observable.subscribe(Observable.java:12076) at io.reactivex.Observable.subscribe(Observable.java:11954) at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:26) collapsed internal calls Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:25) ... 25 more Now let s look at the same example with tagging enabled: io.reactivex.exceptions.OnErrorNotImplementedException: Unhandled error! Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:26) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:25) ... 25 more In the simple case, there s not much added benefit since the execution was synchronous and single threaded, but you can see original trace has now been updated to indicate the exact line that subscribe() was called. In this case: ReadMeExample.java:26 . To reduce noise - RxDogTag will wrap the original cause in a synthetic OnErrorNotImplementedException . This uses the original cause s message and doesn t fill in the stacktrace as it s irrelevant to the trace.","title":"Simple"},{"location":"examples/#threading","text":"Consider a more complex example with threading: Observable . just ( 1 ) . subscribeOn ( Schedulers . io ()) . map ( i - null ) . subscribe (); This is a fairly common case in RxJava concurrency. Without tagging, this yields the following trace: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | The mapper function returned a null value. at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.BasicFuseableObserver.onError(BasicFuseableObserver.java:100) at io.reactivex.internal.observers.BasicFuseableObserver.fail(BasicFuseableObserver.java:110) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:59) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NullPointerException: The mapper function returned a null value. at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) ... 14 more Yikes! This is basically impossible to investigate if you re looking at a crash report from the wild. Now the same trace with tagging enabled: io.reactivex.exceptions.OnErrorNotImplementedException: The mapper function returned a null value. Caused by: java.lang.NullPointerException: The mapper function returned a null value. at com.uber.anotherpackage.ReadMeExample.complex(ReadMeExample.java:55) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Now we have the example subscribe line at ReadMeExample.java:55 . It may not be a silver bullet to root-causing why the exception occurred, but at least you know where it s emanating from.","title":"Threading"},{"location":"examples/#delegate-callbacks","text":"Let s look at one more example. This is similar to the previous, but instead of the exception occurring upstream in the chain, the exception occurs in one of the observer callbacks; in this case - onNext . Observable . just ( 1 ) . subscribeOn ( Schedulers . io ()) . subscribe ( i - throwSomething ()); private void throwSomething () { throw new RuntimeException ( Unhandled error! ); } Without tagging, this yields the following trace: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | Unhandled error! at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:67) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.throwSomething(ReadMeExample.java:68) at com.uber.anotherpackage.ReadMeExample.lambda$complexDelegate$1(ReadMeExample.java:63) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:63) ... 14 more Similar to the first example, this isn t terrible to root-cause. onNext is throwing a traceable exception in this trivial case. With tagging enabled: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | Unhandled error! at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:67) at com.uber.rxdogtag.DogTagObserver.lambda$onNext$3(DogTagObserver.java:53) at com.uber.rxdogtag.RxDogTag.guardedDelegateCall(RxDogTag.java:262) at com.uber.rxdogtag.DogTagObserver.onNext(DogTagObserver.java:53) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.complexDelegate(ReadMeExample.java:63) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ Originating callback: onNext ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at com.uber.anotherpackage.ReadMeExample.throwSomething(ReadMeExample.java:68) at com.uber.anotherpackage.ReadMeExample.lambda$complexDelegate$1(ReadMeExample.java:63) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:63) ... 17 more Now we re given added context that this occurred in the onNext callback according to [[ Originating callback: onNext ]] at the subscribe() call at ReadMeExample.java:63 . This callback handling is supported for all the standard callbacks and will report the correct name for each ( onSuccess , onComplete , etc).","title":"Delegate callbacks"},{"location":"shrinking/","text":"Proguard/R8 In order to correctly identify which line is the subscribe() line, RxDogTag requires keeping the names of any types in io.reactivex or com.uber.rxdogtag packages. This doesn t prevent shrinking unused types, and as these are open source projects we don t think keeping these public risks any sort of secret sauce. Keeping names has a negligible impact on APK size as well. If this is an issue for you though, then RxDogTag is probably not the right solution for your project. RxDogTag ships with custom rxdogtag.pro rules in the jar resources to handle this automatically.","title":"Proguard/R8"},{"location":"shrinking/#proguardr8","text":"In order to correctly identify which line is the subscribe() line, RxDogTag requires keeping the names of any types in io.reactivex or com.uber.rxdogtag packages. This doesn t prevent shrinking unused types, and as these are open source projects we don t think keeping these public risks any sort of secret sauce. Keeping names has a negligible impact on APK size as well. If this is an issue for you though, then RxDogTag is probably not the right solution for your project. RxDogTag ships with custom rxdogtag.pro rules in the jar resources to handle this automatically.","title":"Proguard/R8"},{"location":"under-the-hood/","text":"Under the hood More information on LambdaConsumerIntrospection can be found in its implementation PR: https://github.com/ReactiveX/RxJava/pull/5590 Decision tree: - Is the observer an instance of `LambdaConsumerIntrospection`? - Does `hasCustomOnError()` return `false`? - Decorate with a DogTag observer.","title":"Under The Hood"},{"location":"under-the-hood/#under-the-hood","text":"More information on LambdaConsumerIntrospection can be found in its implementation PR: https://github.com/ReactiveX/RxJava/pull/5590 Decision tree: - Is the observer an instance of `LambdaConsumerIntrospection`? - Does `hasCustomOnError()` return `false`? - Decorate with a DogTag observer.","title":"Under the hood"},{"location":"1.x/rxdogtag/","text":"rxdogtag Packages Name Summary com.uber.rxdogtag Index All Types","title":"Home"},{"location":"1.x/rxdogtag/#packages","text":"Name Summary com.uber.rxdogtag","title":"Packages"},{"location":"1.x/rxdogtag/#index","text":"All Types","title":"Index"},{"location":"1.x/rxdogtag/alltypes/","text":"All Types Name Summary com.uber.rxdogtag.ObserverHandler This interface can be used to further decorate or unpack custom subscribers/observers as needed. com.uber.rxdogtag.RxDogTag RxDogTag is a mechanism to automatically detect RxJava observers with no error handling and wrap them in DogTagObserver s that attempt to deduce the line number that subscribe() was called and surface that in the eventual thrown OnErrorNotImplementedException message. com.uber.rxdogtag.RxDogTagErrorReceiver A marker type to indicate that RxDogTag s decorating observers should try the onError() of the delegate of the observer that implements this. com.uber.rxdogtag.RxDogTagTaggedExceptionReceiver A marker type to indicate that RxDogTag s should pass the decorated stacktrace to [` `](../com.uber.rxdogtag/-rx-dog-tag-error-receiver/on-error.md). Note that this will always be tried directly, and no guarded delegate behavior will be attempted even if RxDogTag.Builder#guardObserverCallbacks(boolean) is enabled in configuration.","title":"Home"},{"location":"1.x/rxdogtag/alltypes/#all-types","text":"Name Summary com.uber.rxdogtag.ObserverHandler This interface can be used to further decorate or unpack custom subscribers/observers as needed. com.uber.rxdogtag.RxDogTag RxDogTag is a mechanism to automatically detect RxJava observers with no error handling and wrap them in DogTagObserver s that attempt to deduce the line number that subscribe() was called and surface that in the eventual thrown OnErrorNotImplementedException message. com.uber.rxdogtag.RxDogTagErrorReceiver A marker type to indicate that RxDogTag s decorating observers should try the onError() of the delegate of the observer that implements this. com.uber.rxdogtag.RxDogTagTaggedExceptionReceiver A marker type to indicate that RxDogTag s should pass the decorated stacktrace to [` `](../com.uber.rxdogtag/-rx-dog-tag-error-receiver/on-error.md). Note that this will always be tried directly, and no guarded delegate behavior will be attempted even if RxDogTag.Builder#guardObserverCallbacks(boolean) is enabled in configuration.","title":"All Types"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/","text":"rxdogtag / com.uber.rxdogtag Package com.uber.rxdogtag Types Name Summary ObserverHandler interface ObserverHandler This interface can be used to further decorate or unpack custom subscribers/observers as needed. RxDogTag class RxDogTag RxDogTag is a mechanism to automatically detect RxJava observers with no error handling and wrap them in DogTagObserver s that attempt to deduce the line number that subscribe() was called and surface that in the eventual thrown OnErrorNotImplementedException message. RxDogTagErrorReceiver interface RxDogTagErrorReceiver A marker type to indicate that RxDogTag s decorating observers should try the onError() of the delegate of the observer that implements this. RxDogTagTaggedExceptionReceiver interface RxDogTagTaggedExceptionReceiver : RxDogTagErrorReceiver A marker type to indicate that RxDogTag s should pass the decorated stacktrace to [` `](-rx-dog-tag-error-receiver/on-error.md). Note that this will always be tried directly, and no guarded delegate behavior will be attempted even if RxDogTag.Builder#guardObserverCallbacks(boolean) is enabled in configuration.","title":"Home"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/#package-comuberrxdogtag","text":"","title":"Package com.uber.rxdogtag"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/#types","text":"Name Summary ObserverHandler interface ObserverHandler This interface can be used to further decorate or unpack custom subscribers/observers as needed. RxDogTag class RxDogTag RxDogTag is a mechanism to automatically detect RxJava observers with no error handling and wrap them in DogTagObserver s that attempt to deduce the line number that subscribe() was called and surface that in the eventual thrown OnErrorNotImplementedException message. RxDogTagErrorReceiver interface RxDogTagErrorReceiver A marker type to indicate that RxDogTag s decorating observers should try the onError() of the delegate of the observer that implements this. RxDogTagTaggedExceptionReceiver interface RxDogTagTaggedExceptionReceiver : RxDogTagErrorReceiver A marker type to indicate that RxDogTag s should pass the decorated stacktrace to [` `](-rx-dog-tag-error-receiver/on-error.md). Note that this will always be tried directly, and no guarded delegate behavior will be attempted even if RxDogTag.Builder#guardObserverCallbacks(boolean) is enabled in configuration.","title":"Types"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag-tagged-exception-receiver/","text":"rxdogtag / com.uber.rxdogtag / RxDogTagTaggedExceptionReceiver RxDogTagTaggedExceptionReceiver interface RxDogTagTaggedExceptionReceiver : RxDogTagErrorReceiver A marker type to indicate that RxDogTag s should pass the decorated stacktrace to [` `](-rx-dog-tag-error-receiver/on-error.md). Note that this will always be tried directly, and no guarded delegate behavior will be attempted even if RxDogTag.Builder#guardObserverCallbacks(boolean) is enabled in configuration. NOTE: RxDogTag exceptions are always OnErrorNotImplementedException, as these have special behavior as an escape hatch in RxJava internals. This exception will have no cause property if the original exception was not already an OnErrorNotImplementedException. If it was, which is unusual, it is reused with its original cause (if any) and has its stacktrace modified. Inherited Functions Name Summary onError abstract fun onError(e: Throwable !): Unit Called once if the deferred computation throws an exception.","title":" rx dog tag tagged exception receiver"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag-tagged-exception-receiver/#rxdogtagtaggedexceptionreceiver","text":"interface RxDogTagTaggedExceptionReceiver : RxDogTagErrorReceiver A marker type to indicate that RxDogTag s should pass the decorated stacktrace to [` `](-rx-dog-tag-error-receiver/on-error.md). Note that this will always be tried directly, and no guarded delegate behavior will be attempted even if RxDogTag.Builder#guardObserverCallbacks(boolean) is enabled in configuration. NOTE: RxDogTag exceptions are always OnErrorNotImplementedException, as these have special behavior as an escape hatch in RxJava internals. This exception will have no cause property if the original exception was not already an OnErrorNotImplementedException. If it was, which is unusual, it is reused with its original cause (if any) and has its stacktrace modified.","title":"RxDogTagTaggedExceptionReceiver"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag-tagged-exception-receiver/#inherited-functions","text":"Name Summary onError abstract fun onError(e: Throwable !): Unit Called once if the deferred computation throws an exception.","title":"Inherited Functions"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-observer-handler/","text":"rxdogtag / com.uber.rxdogtag / ObserverHandler ObserverHandler interface ObserverHandler This interface can be used to further decorate or unpack custom subscribers/observers as needed. Example use cases: Unpacking custom observers to yield their underlying delegate observers or behavior. Decorating observers with custom runtime behavior. Note: The observer returned here will NOT be used for anything other than determining if there is custom error handling. Functions Name Summary handle open fun handle(flowable: Flowable!, subscriber: Subscriber!): Subscriber! Callbacks to handle Flowable and Subscriber. open fun handle(observable: Observable!, observer: Observer!): Observer! Callbacks to handle Observable and Observer. open fun handle(maybe: Maybe!, observer: MaybeObserver!): MaybeObserver! Callbacks to handle Maybe and MaybeObserver. open fun handle(single: Single!, observer: SingleObserver!): SingleObserver! Callbacks to handle Single and SingleObserver. open fun handle(completable: Completable!, observer: CompletableObserver!): CompletableObserver! Callbacks to handle Completable and CompletableObserver.","title":"Home"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-observer-handler/#observerhandler","text":"interface ObserverHandler This interface can be used to further decorate or unpack custom subscribers/observers as needed. Example use cases: Unpacking custom observers to yield their underlying delegate observers or behavior. Decorating observers with custom runtime behavior. Note: The observer returned here will NOT be used for anything other than determining if there is custom error handling.","title":"ObserverHandler"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-observer-handler/#functions","text":"Name Summary handle open fun handle(flowable: Flowable!, subscriber: Subscriber!): Subscriber! Callbacks to handle Flowable and Subscriber. open fun handle(observable: Observable!, observer: Observer!): Observer! Callbacks to handle Observable and Observer. open fun handle(maybe: Maybe!, observer: MaybeObserver!): MaybeObserver! Callbacks to handle Maybe and MaybeObserver. open fun handle(single: Single!, observer: SingleObserver!): SingleObserver! Callbacks to handle Single and SingleObserver. open fun handle(completable: Completable!, observer: CompletableObserver!): CompletableObserver! Callbacks to handle Completable and CompletableObserver.","title":"Functions"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-observer-handler/handle/","text":"rxdogtag / com.uber.rxdogtag / ObserverHandler / handle handle open fun handle(flowable: Flowable!, subscriber: Subscriber!): Subscriber! Callbacks to handle Flowable and Subscriber. Parameters flowable - Flowable!: the source flowable. subscriber - Subscriber!: the source subscriber. Return Subscriber!: possible decorated or unpacked observer. open fun handle(observable: Observable!, observer: Observer!): Observer! Callbacks to handle Observable and Observer. Parameters observable - the source observable. observer - the source observer. Return Subscriber!: possible decorated or unpacked observer. open fun handle(maybe: Maybe!, observer: MaybeObserver!): MaybeObserver! Callbacks to handle Maybe and MaybeObserver. Parameters maybe - the source maybe. observer - the source observer. Return Subscriber!: possible decorated or unpacked observer. open fun handle(single: Single!, observer: SingleObserver!): SingleObserver! Callbacks to handle Single and SingleObserver. Parameters single - the source single. observer - the source observer. Return Subscriber!: possible decorated or unpacked observer. open fun handle(completable: Completable!, observer: CompletableObserver!): CompletableObserver! Callbacks to handle Completable and CompletableObserver. Parameters completable - the source completable. observer - the source observer. Return Subscriber!: possible decorated or unpacked observer.","title":"Handle"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-observer-handler/handle/#handle","text":"open fun handle(flowable: Flowable!, subscriber: Subscriber!): Subscriber! Callbacks to handle Flowable and Subscriber.","title":"handle"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-observer-handler/handle/#parameters","text":"flowable - Flowable!: the source flowable. subscriber - Subscriber!: the source subscriber. Return Subscriber!: possible decorated or unpacked observer. open fun handle(observable: Observable!, observer: Observer!): Observer! Callbacks to handle Observable and Observer.","title":"Parameters"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-observer-handler/handle/#parameters_1","text":"observable - the source observable. observer - the source observer. Return Subscriber!: possible decorated or unpacked observer. open fun handle(maybe: Maybe!, observer: MaybeObserver!): MaybeObserver! Callbacks to handle Maybe and MaybeObserver.","title":"Parameters"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-observer-handler/handle/#parameters_2","text":"maybe - the source maybe. observer - the source observer. Return Subscriber!: possible decorated or unpacked observer. open fun handle(single: Single!, observer: SingleObserver!): SingleObserver! Callbacks to handle Single and SingleObserver.","title":"Parameters"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-observer-handler/handle/#parameters_3","text":"single - the source single. observer - the source observer. Return Subscriber!: possible decorated or unpacked observer. open fun handle(completable: Completable!, observer: CompletableObserver!): CompletableObserver! Callbacks to handle Completable and CompletableObserver.","title":"Parameters"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-observer-handler/handle/#parameters_4","text":"completable - the source completable. observer - the source observer. Return Subscriber!: possible decorated or unpacked observer.","title":"Parameters"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag RxDogTag class RxDogTag RxDogTag is a mechanism to automatically detect RxJava observers with no error handling and wrap them in DogTagObserver s that attempt to deduce the line number that subscribe() was called and surface that in the eventual thrown OnErrorNotImplementedException message. To use, simply call [`#install`](install.md) or use #builder() to install with configuration. Note that this uses RxJavaPlugins s onSubscribe hooks. Types Name Summary Builder class Builder Configurer interface Configurer Convenience interface to allow custom configurers to hook into a builder to add their own configurations as needed. Properties Name Summary STACK_ELEMENT_SOURCE_DELEGATE static val STACK_ELEMENT_SOURCE_DELEGATE: String STACK_ELEMENT_SOURCE_HEADER static val STACK_ELEMENT_SOURCE_HEADER: String STACK_ELEMENT_TRACE_HEADER static val STACK_ELEMENT_TRACE_HEADER: String Functions Name Summary builder static fun builder(): RxDogTag.Builder ! install static fun install(): Unit Initializes RxDogTag with default [`Builder`](-builder/index.md) settings via Builder#install() . reset static fun reset(): Unit Resets RxDogTag by resetting custom onSubscribe hooks via RxJavaPlugins. Note that calling this calls the following methods with null values.","title":"Home"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/#rxdogtag","text":"class RxDogTag RxDogTag is a mechanism to automatically detect RxJava observers with no error handling and wrap them in DogTagObserver s that attempt to deduce the line number that subscribe() was called and surface that in the eventual thrown OnErrorNotImplementedException message. To use, simply call [`#install`](install.md) or use #builder() to install with configuration. Note that this uses RxJavaPlugins s onSubscribe hooks.","title":"RxDogTag"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/#types","text":"Name Summary Builder class Builder Configurer interface Configurer Convenience interface to allow custom configurers to hook into a builder to add their own configurations as needed.","title":"Types"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/#properties","text":"Name Summary STACK_ELEMENT_SOURCE_DELEGATE static val STACK_ELEMENT_SOURCE_DELEGATE: String STACK_ELEMENT_SOURCE_HEADER static val STACK_ELEMENT_SOURCE_HEADER: String STACK_ELEMENT_TRACE_HEADER static val STACK_ELEMENT_TRACE_HEADER: String","title":"Properties"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/#functions","text":"Name Summary builder static fun builder(): RxDogTag.Builder ! install static fun install(): Unit Initializes RxDogTag with default [`Builder`](-builder/index.md) settings via Builder#install() . reset static fun reset(): Unit Resets RxDogTag by resetting custom onSubscribe hooks via RxJavaPlugins. Note that calling this calls the following methods with null values.","title":"Functions"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-s-t-a-c-k_-e-l-e-m-e-n-t_-s-o-u-r-c-e_-d-e-l-e-g-a-t-e/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / STACK_ELEMENT_SOURCE_DELEGATE STACK_ELEMENT_SOURCE_DELEGATE static val STACK_ELEMENT_SOURCE_DELEGATE: String","title":" s t a c k  e l e m e n t  s o u r c e  d e l e g a t e"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-s-t-a-c-k_-e-l-e-m-e-n-t_-s-o-u-r-c-e_-d-e-l-e-g-a-t-e/#stack_element_source_delegate","text":"static val STACK_ELEMENT_SOURCE_DELEGATE: String","title":"STACK_ELEMENT_SOURCE_DELEGATE"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-s-t-a-c-k_-e-l-e-m-e-n-t_-s-o-u-r-c-e_-h-e-a-d-e-r/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / STACK_ELEMENT_SOURCE_HEADER STACK_ELEMENT_SOURCE_HEADER static val STACK_ELEMENT_SOURCE_HEADER: String","title":" s t a c k  e l e m e n t  s o u r c e  h e a d e r"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-s-t-a-c-k_-e-l-e-m-e-n-t_-s-o-u-r-c-e_-h-e-a-d-e-r/#stack_element_source_header","text":"static val STACK_ELEMENT_SOURCE_HEADER: String","title":"STACK_ELEMENT_SOURCE_HEADER"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-s-t-a-c-k_-e-l-e-m-e-n-t_-t-r-a-c-e_-h-e-a-d-e-r/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / STACK_ELEMENT_TRACE_HEADER STACK_ELEMENT_TRACE_HEADER static val STACK_ELEMENT_TRACE_HEADER: String","title":" s t a c k  e l e m e n t  t r a c e  h e a d e r"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-s-t-a-c-k_-e-l-e-m-e-n-t_-t-r-a-c-e_-h-e-a-d-e-r/#stack_element_trace_header","text":"static val STACK_ELEMENT_TRACE_HEADER: String","title":"STACK_ELEMENT_TRACE_HEADER"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/builder/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / builder builder static fun builder(): RxDogTag.Builder ! Return RxDogTag.Builder !: a new `[ Builder`](-builder/index.md) to configure and install RxDogTag with.","title":"Builder"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/builder/#builder","text":"static fun builder(): RxDogTag.Builder ! Return RxDogTag.Builder !: a new `[ Builder`](-builder/index.md) to configure and install RxDogTag with.","title":"builder"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/install/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / install install static fun install(): Unit Initializes RxDogTag with default [`Builder`](-builder/index.md) settings via Builder#install() . RxJavaPlugins#setOnFlowableSubscribe(BiFunction) RxJavaPlugins#setOnObservableSubscribe(BiFunction) RxJavaPlugins#setOnMaybeSubscribe(BiFunction) RxJavaPlugins#setOnSingleSubscribe(BiFunction) RxJavaPlugins#setOnCompletableSubscribe(BiFunction) See Also #extractStackElementTag(Throwable, Set)","title":"Install"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/install/#install","text":"static fun install(): Unit Initializes RxDogTag with default [`Builder`](-builder/index.md) settings via Builder#install() . RxJavaPlugins#setOnFlowableSubscribe(BiFunction) RxJavaPlugins#setOnObservableSubscribe(BiFunction) RxJavaPlugins#setOnMaybeSubscribe(BiFunction) RxJavaPlugins#setOnSingleSubscribe(BiFunction) RxJavaPlugins#setOnCompletableSubscribe(BiFunction) See Also #extractStackElementTag(Throwable, Set)","title":"install"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/reset/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / reset reset static fun reset(): Unit Resets RxDogTag by resetting custom onSubscribe hooks via RxJavaPlugins. Note that calling this calls the following methods with null values. RxJavaPlugins#setOnFlowableSubscribe(BiFunction) RxJavaPlugins#setOnObservableSubscribe(BiFunction) RxJavaPlugins#setOnMaybeSubscribe(BiFunction) RxJavaPlugins#setOnSingleSubscribe(BiFunction) RxJavaPlugins#setOnCompletableSubscribe(BiFunction)","title":"Reset"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/reset/#reset","text":"static fun reset(): Unit Resets RxDogTag by resetting custom onSubscribe hooks via RxJavaPlugins. Note that calling this calls the following methods with null values. RxJavaPlugins#setOnFlowableSubscribe(BiFunction) RxJavaPlugins#setOnObservableSubscribe(BiFunction) RxJavaPlugins#setOnMaybeSubscribe(BiFunction) RxJavaPlugins#setOnSingleSubscribe(BiFunction) RxJavaPlugins#setOnCompletableSubscribe(BiFunction)","title":"reset"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / Builder Builder class Builder Functions Name Summary addIgnoredPackages fun addIgnoredPackages(vararg packages: String !): RxDogTag.Builder ! fun addIgnoredPackages(packages: MutableCollection String ! !): RxDogTag.Builder ! addObserverHandlers fun addObserverHandlers(vararg handlers: ObserverHandler !): RxDogTag.Builder ! fun addObserverHandlers(handlers: MutableCollection ObserverHandler ! !): RxDogTag.Builder ! configureWith fun configureWith(configurer: RxDogTag.Configurer !): RxDogTag.Builder ! Can be used to compose this builder with a `[ Configurer`](../-configurer/index.md) in a way that doesn t break the builder chain. disableAnnotations fun disableAnnotations(): RxDogTag.Builder ! Disables stacktrace annotations. No headers like `[ #STACK_ELEMENT_TRACE_HEADER`](../-s-t-a-c-k_-e-l-e-m-e-n-t_-t-r-a-c-e_-h-e-a-d-e-r.md) will be present in the stack if this is disabled. disableRepackagingOnErrorNotImplementedExceptions fun disableRepackagingOnErrorNotImplementedExceptions(): RxDogTag.Builder ! By default, RxDogTag will repackage OnErrorNotImplementedException with its own custom, simplified one with no stacktrace and the original cause s message copied in. This is effectively the same behavior as any other type of exception. guardObserverCallbacks fun guardObserverCallbacks(guardObserverCallbacks: Boolean ): RxDogTag.Builder ! install fun install(): Unit Initializes RxDogTag by installing custom onSubscribe hooks via RxJavaPlugins. Note that calling this calls the following methods:","title":"Home"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/#builder","text":"class Builder","title":"Builder"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/#functions","text":"Name Summary addIgnoredPackages fun addIgnoredPackages(vararg packages: String !): RxDogTag.Builder ! fun addIgnoredPackages(packages: MutableCollection String ! !): RxDogTag.Builder ! addObserverHandlers fun addObserverHandlers(vararg handlers: ObserverHandler !): RxDogTag.Builder ! fun addObserverHandlers(handlers: MutableCollection ObserverHandler ! !): RxDogTag.Builder ! configureWith fun configureWith(configurer: RxDogTag.Configurer !): RxDogTag.Builder ! Can be used to compose this builder with a `[ Configurer`](../-configurer/index.md) in a way that doesn t break the builder chain. disableAnnotations fun disableAnnotations(): RxDogTag.Builder ! Disables stacktrace annotations. No headers like `[ #STACK_ELEMENT_TRACE_HEADER`](../-s-t-a-c-k_-e-l-e-m-e-n-t_-t-r-a-c-e_-h-e-a-d-e-r.md) will be present in the stack if this is disabled. disableRepackagingOnErrorNotImplementedExceptions fun disableRepackagingOnErrorNotImplementedExceptions(): RxDogTag.Builder ! By default, RxDogTag will repackage OnErrorNotImplementedException with its own custom, simplified one with no stacktrace and the original cause s message copied in. This is effectively the same behavior as any other type of exception. guardObserverCallbacks fun guardObserverCallbacks(guardObserverCallbacks: Boolean ): RxDogTag.Builder ! install fun install(): Unit Initializes RxDogTag by installing custom onSubscribe hooks via RxJavaPlugins. Note that calling this calls the following methods:","title":"Functions"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/add-ignored-packages/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / Builder / addIgnoredPackages addIgnoredPackages fun addIgnoredPackages(vararg packages: String !): RxDogTag.Builder ! Parameters packages - String !: ignorable packages. Useful if decorating observers that you know can be safely ignored when deducing a target subscribe() point. It s recommended that classes in these packages have their names kept in Proguard/R8 obfuscation as well. Return RxDogTag.Builder !: this builder for fluent chaining. fun addIgnoredPackages(packages: MutableCollection String ! !): RxDogTag.Builder ! Parameters packages - MutableCollection String ! !: ignorable packages. Useful if decorating observers that you know can be safely ignored when deducing a target subscribe() point. It s recommended that classes in these packages have their names kept in Proguard/R8 obfuscation as well. Return RxDogTag.Builder !: this builder for fluent chaining.","title":"Add ignored packages"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/add-ignored-packages/#addignoredpackages","text":"fun addIgnoredPackages(vararg packages: String !): RxDogTag.Builder !","title":"addIgnoredPackages"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/add-ignored-packages/#parameters","text":"packages - String !: ignorable packages. Useful if decorating observers that you know can be safely ignored when deducing a target subscribe() point. It s recommended that classes in these packages have their names kept in Proguard/R8 obfuscation as well. Return RxDogTag.Builder !: this builder for fluent chaining. fun addIgnoredPackages(packages: MutableCollection String ! !): RxDogTag.Builder !","title":"Parameters"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/add-ignored-packages/#parameters_1","text":"packages - MutableCollection String ! !: ignorable packages. Useful if decorating observers that you know can be safely ignored when deducing a target subscribe() point. It s recommended that classes in these packages have their names kept in Proguard/R8 obfuscation as well. Return RxDogTag.Builder !: this builder for fluent chaining.","title":"Parameters"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/add-observer-handlers/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / Builder / addObserverHandlers addObserverHandlers fun addObserverHandlers(vararg handlers: ObserverHandler !): RxDogTag.Builder ! Parameters handlers - ObserverHandler !: any number of `[ ObserverHandler`](../../-observer-handler/index.md) instances to potentially unpack or decorate observers. Note that order matters here, and the first one to return a with no custom error handling will be used. Return RxDogTag.Builder !: this builder for fluent chaining. fun addObserverHandlers(handlers: MutableCollection ObserverHandler ! !): RxDogTag.Builder ! Parameters handlers - MutableCollection ObserverHandler ! !: a list of `[ ObserverHandler`](../../-observer-handler/index.md) instances to potentially unpack or decorate observers. Note that order matters here, and the first one to return a with no custom error handling will be used. Return RxDogTag.Builder !: this builder for fluent chaining.","title":"Add observer handlers"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/add-observer-handlers/#addobserverhandlers","text":"fun addObserverHandlers(vararg handlers: ObserverHandler !): RxDogTag.Builder !","title":"addObserverHandlers"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/add-observer-handlers/#parameters","text":"handlers - ObserverHandler !: any number of `[ ObserverHandler`](../../-observer-handler/index.md) instances to potentially unpack or decorate observers. Note that order matters here, and the first one to return a with no custom error handling will be used. Return RxDogTag.Builder !: this builder for fluent chaining. fun addObserverHandlers(handlers: MutableCollection ObserverHandler ! !): RxDogTag.Builder !","title":"Parameters"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/add-observer-handlers/#parameters_1","text":"handlers - MutableCollection ObserverHandler ! !: a list of `[ ObserverHandler`](../../-observer-handler/index.md) instances to potentially unpack or decorate observers. Note that order matters here, and the first one to return a with no custom error handling will be used. Return RxDogTag.Builder !: this builder for fluent chaining.","title":"Parameters"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/configure-with/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / Builder / configureWith configureWith fun configureWith(configurer: RxDogTag.Configurer !): RxDogTag.Builder ! Can be used to compose this builder with a `[ Configurer`](../-configurer/index.md) in a way that doesn t break the builder chain. Example: ``` RxDogTag.builder() .configureWith(AutoDisposeConfigurer::configure) .install(); ``` Parameters configurer - RxDogTag.Configurer !: an `[ Configurer`](../-configurer/index.md) instance to be called. Return RxDogTag.Builder !: this builder for fluent chaining.","title":"Configure with"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/configure-with/#configurewith","text":"fun configureWith(configurer: RxDogTag.Configurer !): RxDogTag.Builder ! Can be used to compose this builder with a `[ Configurer`](../-configurer/index.md) in a way that doesn t break the builder chain. Example: ``` RxDogTag.builder() .configureWith(AutoDisposeConfigurer::configure) .install(); ```","title":"configureWith"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/configure-with/#parameters","text":"configurer - RxDogTag.Configurer !: an `[ Configurer`](../-configurer/index.md) instance to be called. Return RxDogTag.Builder !: this builder for fluent chaining.","title":"Parameters"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/disable-annotations/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / Builder / disableAnnotations disableAnnotations fun disableAnnotations(): RxDogTag.Builder ! Disables stacktrace annotations. No headers like `[ #STACK_ELEMENT_TRACE_HEADER`](../-s-t-a-c-k_-e-l-e-m-e-n-t_-t-r-a-c-e_-h-e-a-d-e-r.md) will be present in the stack if this is disabled. Return RxDogTag.Builder !: this builder for fluent chaining.","title":"Disable annotations"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/disable-annotations/#disableannotations","text":"fun disableAnnotations(): RxDogTag.Builder ! Disables stacktrace annotations. No headers like `[ #STACK_ELEMENT_TRACE_HEADER`](../-s-t-a-c-k_-e-l-e-m-e-n-t_-t-r-a-c-e_-h-e-a-d-e-r.md) will be present in the stack if this is disabled. Return RxDogTag.Builder !: this builder for fluent chaining.","title":"disableAnnotations"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/disable-repackaging-on-error-not-implemented-exceptions/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / Builder / disableRepackagingOnErrorNotImplementedExceptions disableRepackagingOnErrorNotImplementedExceptions fun disableRepackagingOnErrorNotImplementedExceptions(): RxDogTag.Builder ! By default, RxDogTag will repackage OnErrorNotImplementedException with its own custom, simplified one with no stacktrace and the original cause s message copied in. This is effectively the same behavior as any other type of exception. If you don t want this behavior, you can use this configuration to disable that behavior. This should only be disabled if you throw your own custom that you want visible in the stacktrace. Return RxDogTag.Builder !: this builder for fluent chaining.","title":"Disable repackaging on error not implemented exceptions"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/disable-repackaging-on-error-not-implemented-exceptions/#disablerepackagingonerrornotimplementedexceptions","text":"fun disableRepackagingOnErrorNotImplementedExceptions(): RxDogTag.Builder ! By default, RxDogTag will repackage OnErrorNotImplementedException with its own custom, simplified one with no stacktrace and the original cause s message copied in. This is effectively the same behavior as any other type of exception. If you don t want this behavior, you can use this configuration to disable that behavior. This should only be disabled if you throw your own custom that you want visible in the stacktrace. Return RxDogTag.Builder !: this builder for fluent chaining.","title":"disableRepackagingOnErrorNotImplementedExceptions"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/guard-observer-callbacks/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / Builder / guardObserverCallbacks guardObserverCallbacks fun guardObserverCallbacks(guardObserverCallbacks: Boolean ): RxDogTag.Builder ! Parameters guardObserverCallbacks - Boolean : Guards observer callbacks so that any exceptions that occur during observer callbacks are intercepted and routed to RxDogTag s error handling that will give you more info on the subscription point. Set to true by default. Return RxDogTag.Builder !: this builder for fluent chaining.","title":"Guard observer callbacks"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/guard-observer-callbacks/#guardobservercallbacks","text":"fun guardObserverCallbacks(guardObserverCallbacks: Boolean ): RxDogTag.Builder !","title":"guardObserverCallbacks"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/guard-observer-callbacks/#parameters","text":"guardObserverCallbacks - Boolean : Guards observer callbacks so that any exceptions that occur during observer callbacks are intercepted and routed to RxDogTag s error handling that will give you more info on the subscription point. Set to true by default. Return RxDogTag.Builder !: this builder for fluent chaining.","title":"Parameters"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/install/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / Builder / install install fun install(): Unit Initializes RxDogTag by installing custom onSubscribe hooks via RxJavaPlugins. Note that calling this calls the following methods: RxJavaPlugins#setOnFlowableSubscribe(BiFunction) RxJavaPlugins#setOnObservableSubscribe(BiFunction) RxJavaPlugins#setOnMaybeSubscribe(BiFunction) RxJavaPlugins#setOnSingleSubscribe(BiFunction) RxJavaPlugins#setOnCompletableSubscribe(BiFunction) See Also #extractStackElementTag(Throwable, Set)","title":"Install"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-builder/install/#install","text":"fun install(): Unit Initializes RxDogTag by installing custom onSubscribe hooks via RxJavaPlugins. Note that calling this calls the following methods: RxJavaPlugins#setOnFlowableSubscribe(BiFunction) RxJavaPlugins#setOnObservableSubscribe(BiFunction) RxJavaPlugins#setOnMaybeSubscribe(BiFunction) RxJavaPlugins#setOnSingleSubscribe(BiFunction) RxJavaPlugins#setOnCompletableSubscribe(BiFunction) See Also #extractStackElementTag(Throwable, Set)","title":"install"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-configurer/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / Configurer Configurer interface Configurer Convenience interface to allow custom configurers to hook into a builder to add their own configurations as needed. See Also Builder#configureWith(Configurer) Functions Name Summary apply abstract fun apply(builder: RxDogTag.Builder !): Unit Called to configure the given builder instance as needed.","title":"Home"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-configurer/#configurer","text":"interface Configurer Convenience interface to allow custom configurers to hook into a builder to add their own configurations as needed. See Also Builder#configureWith(Configurer)","title":"Configurer"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-configurer/#functions","text":"Name Summary apply abstract fun apply(builder: RxDogTag.Builder !): Unit Called to configure the given builder instance as needed.","title":"Functions"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-configurer/apply/","text":"rxdogtag / com.uber.rxdogtag / RxDogTag / Configurer / apply apply abstract fun apply(builder: RxDogTag.Builder !): Unit Called to configure the given builder instance as needed. Parameters builder - RxDogTag.Builder !: the `[ Builder`](../-builder/index.md) to configure.","title":"Apply"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-configurer/apply/#apply","text":"abstract fun apply(builder: RxDogTag.Builder !): Unit Called to configure the given builder instance as needed.","title":"apply"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag/-configurer/apply/#parameters","text":"builder - RxDogTag.Builder !: the `[ Builder`](../-builder/index.md) to configure.","title":"Parameters"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag-error-receiver/","text":"rxdogtag / com.uber.rxdogtag / RxDogTagErrorReceiver RxDogTagErrorReceiver interface RxDogTagErrorReceiver A marker type to indicate that RxDogTag s decorating observers should try the onError() of the delegate of the observer that implements this. Functions Name Summary onError abstract fun onError(e: Throwable !): Unit Called once if the deferred computation throws an exception. Inheritors Name Summary RxDogTagTaggedExceptionReceiver interface RxDogTagTaggedExceptionReceiver : RxDogTagErrorReceiver A marker type to indicate that RxDogTag s should pass the decorated stacktrace to [` `](on-error.md). Note that this will always be tried directly, and no guarded delegate behavior will be attempted even if RxDogTag.Builder#guardObserverCallbacks(boolean) is enabled in configuration.","title":"Home"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag-error-receiver/#rxdogtagerrorreceiver","text":"interface RxDogTagErrorReceiver A marker type to indicate that RxDogTag s decorating observers should try the onError() of the delegate of the observer that implements this.","title":"RxDogTagErrorReceiver"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag-error-receiver/#functions","text":"Name Summary onError abstract fun onError(e: Throwable !): Unit Called once if the deferred computation throws an exception.","title":"Functions"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag-error-receiver/#inheritors","text":"Name Summary RxDogTagTaggedExceptionReceiver interface RxDogTagTaggedExceptionReceiver : RxDogTagErrorReceiver A marker type to indicate that RxDogTag s should pass the decorated stacktrace to [` `](on-error.md). Note that this will always be tried directly, and no guarded delegate behavior will be attempted even if RxDogTag.Builder#guardObserverCallbacks(boolean) is enabled in configuration.","title":"Inheritors"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag-error-receiver/on-error/","text":"rxdogtag / com.uber.rxdogtag / RxDogTagErrorReceiver / onError onError abstract fun onError(e: Throwable !): Unit Called once if the deferred computation throws an exception. Parameters e - Throwable !: the exception, not null.","title":"On error"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag-error-receiver/on-error/#onerror","text":"abstract fun onError(e: Throwable !): Unit Called once if the deferred computation throws an exception.","title":"onError"},{"location":"1.x/rxdogtag/com.uber.rxdogtag/-rx-dog-tag-error-receiver/on-error/#parameters","text":"e - Throwable !: the exception, not null.","title":"Parameters"},{"location":"1.x/rxdogtag-autodispose/","text":"rxdogtag-autodispose Packages Name Summary com.uber.rxdogtag.autodispose Index All Types","title":"Home"},{"location":"1.x/rxdogtag-autodispose/#packages","text":"Name Summary com.uber.rxdogtag.autodispose","title":"Packages"},{"location":"1.x/rxdogtag-autodispose/#index","text":"All Types","title":"Index"},{"location":"1.x/rxdogtag-autodispose/alltypes/","text":"All Types Name Summary com.uber.rxdogtag.autodispose.AutoDisposeConfigurer Configures an RxDogTag.Builder with: A ObserverHandler that supports handling AutoDispose s decorating observers to retrieve their underlying delegate observers. Ignored packages.","title":"Home"},{"location":"1.x/rxdogtag-autodispose/alltypes/#all-types","text":"Name Summary com.uber.rxdogtag.autodispose.AutoDisposeConfigurer Configures an RxDogTag.Builder with: A ObserverHandler that supports handling AutoDispose s decorating observers to retrieve their underlying delegate observers. Ignored packages.","title":"All Types"},{"location":"1.x/rxdogtag-autodispose/com.uber.rxdogtag.autodispose/","text":"rxdogtag-autodispose / com.uber.rxdogtag.autodispose Package com.uber.rxdogtag.autodispose Types Name Summary AutoDisposeConfigurer class AutoDisposeConfigurer Configures an RxDogTag.Builder with: A ObserverHandler that supports handling AutoDispose s decorating observers to retrieve their underlying delegate observers. Ignored packages.","title":"Home"},{"location":"1.x/rxdogtag-autodispose/com.uber.rxdogtag.autodispose/#package-comuberrxdogtagautodispose","text":"","title":"Package com.uber.rxdogtag.autodispose"},{"location":"1.x/rxdogtag-autodispose/com.uber.rxdogtag.autodispose/#types","text":"Name Summary AutoDisposeConfigurer class AutoDisposeConfigurer Configures an RxDogTag.Builder with: A ObserverHandler that supports handling AutoDispose s decorating observers to retrieve their underlying delegate observers. Ignored packages.","title":"Types"},{"location":"1.x/rxdogtag-autodispose/com.uber.rxdogtag.autodispose/-auto-dispose-configurer/","text":"rxdogtag-autodispose / com.uber.rxdogtag.autodispose / AutoDisposeConfigurer AutoDisposeConfigurer class AutoDisposeConfigurer Configures an RxDogTag.Builder with: * A ObserverHandler that supports handling AutoDispose s decorating observers to retrieve their underlying delegate observers. * Ignored packages. Usage: Configure with `[ #configure(RxDogTag.Builder)`](configure.md). Functions Name Summary configure static fun configure(builder: Builder!): Unit","title":"Home"},{"location":"1.x/rxdogtag-autodispose/com.uber.rxdogtag.autodispose/-auto-dispose-configurer/#autodisposeconfigurer","text":"class AutoDisposeConfigurer Configures an RxDogTag.Builder with: * A ObserverHandler that supports handling AutoDispose s decorating observers to retrieve their underlying delegate observers. * Ignored packages. Usage: Configure with `[ #configure(RxDogTag.Builder)`](configure.md).","title":"AutoDisposeConfigurer"},{"location":"1.x/rxdogtag-autodispose/com.uber.rxdogtag.autodispose/-auto-dispose-configurer/#functions","text":"Name Summary configure static fun configure(builder: Builder!): Unit","title":"Functions"},{"location":"1.x/rxdogtag-autodispose/com.uber.rxdogtag.autodispose/-auto-dispose-configurer/configure/","text":"rxdogtag-autodispose / com.uber.rxdogtag.autodispose / AutoDisposeConfigurer / configure configure static fun configure(builder: Builder!): Unit","title":"Configure"},{"location":"1.x/rxdogtag-autodispose/com.uber.rxdogtag.autodispose/-auto-dispose-configurer/configure/#configure","text":"static fun configure(builder: Builder!): Unit","title":"configure"}]}